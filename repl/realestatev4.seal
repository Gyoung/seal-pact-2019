;;
;; RealEstate contract model, version III.
;;

;; 问题：直接transfer to address? 内部要维护balance?


(defcontract realestateContract admin-address

  ;;(defevent transfer-event [^address from ^address to ^string token-id])
  
  (defrecord realestate
      [^string name
       ^string type
       ^string info
       ^decimal buy-price
       ^decimal total-shares
       ^decimal available-shares
       ^address owner])

  (deftable realestate-table ^{realestate}) ;; key: ^string token-id

  (defrecord stakeholder
      [^address owner
       ^decimal shares])

  (deftable stakeholder-table ^{stakeholder}) ;; key: ^string (hash token-id holder)

  (defrecord allowance
    [^decimal allowed
     ^address holder
     ;; ^address spender
     ])

  ;; use (hash [sender receiver]) as id
  ;;(deftable allowance-table ^{allowance})

  (defn- get-hash [owner spender]
    (hash [owner spender]))

  (defn- get-key [a b]
    (+ (+ a "/") b))

  (defn- get-first-key [key]
    (take 20 key))

  (defn- get-last-key [key]
    (drop 21 key))

  (defn token.new
    [id name type owner info]
    (let [me (MSG_SENDER)]
      (enforce (= admin-address me) "need admin")
      ;; TODO
      (let [token-id (GENERATE UNIQUE-TOKEN-ID)]
        (insert realestate-table token-id
                {:name             name
                 :type             type
                 :owner            owner
                 :info             info
                 :buy-price        0
                 :total-shares     0
                 :available-shares 0})
        token-id)))

  (defn token.startIssue
    [token-id total-shares buy-price info]
    (let [me (MSG_SENDER)]
      (enforce (= admin-address me) "need admin")
      (with-default-read realestate-table token-id
        {:buy-price -1}
        {buy-price :buy-price}
        (enforce (not= -1 buy-price) "token-id not exists")
        (update realestate-table token-id
                {:total-shares total-shares
                 :buy-price buy-price
                 :info info}))))

  (defn token.stopIssue
    [token-id]
    (let [me (MSG_SENDER)]
      (enforce (= admin-address me) "need admin")
      (with-default-read realestate-table token-id
        {:buy-price -1}
        {buy-price :buy-price}
        (enforce (not= -1 buy-price) "token-id not exists")
        (update realestate-table token-id
                {:buy-price 0}))))

  (defn token.return ;; return what?
    [token-id]
    (let [me (MSG_SENDER)]
      ;; (enforce (= admin-address me) "need admin")
      (with-default-read realestate-table token-id
        {:buy-price -1}
        {buy-price :buy-price}
        (enforce (not= -1 buy-price) "token-id not exists")
        (enforce (= me owner) "need owner"))))

  (defn token.balance
    [addr token-id]
    )

  (defn token.announce ;; 发公告
    [token-id str])

  (defn token.info
    [token-id]
    (with-default-read realestate-table token-id
      {:info ""}
      {info :info}
      info))

  (defn token.announces ;; 查询公告
    [token-id]
    (with-default-read realestate-table token-id ;; 小表?
      {}))
  

  (defn total-shares [token-id]
    (with-read realestate-table token-id
      {shares :total-shares}
      shares))
  
  (defn available-shares [token-id]
    (with-read realestate-table token-id
      {shares :available-shares}
      shares))

  (defn change-price [token-id buy-price sell-price]
    (enforce (= admin-address (MSG_SENDER)) "need admin")
    (update realestate-table token-id
            {:buy-price buy-price :sell-price sell-price}))

  (defn- upsert-add [table key field amount]
    (with-default-read table key {field -1} {old-amount field}
      (if (= -1 old-amount)
        (insert table key {field amount})
        (update table key {field (+ amount old-amount)}))))

  (defn token.buy [token-id shares]
    (enforce (>= shares 300) "Invalid Shares")
    (with-read realestate-table token-id
      {buy-price :buy-price
       available-shares :available-shares
       owner :owner}
      (enforce (>= available-shares shares) "Insufficient Available Shares")
      (let [cost (* buy-price shares)
            me (MSG_SENDER)
            id (get-hash token-id me)]
        (send owner me cost) ;; send to from value
        (upsert-add stakeholder-table id :shares shares)
        (update realestate-table token-id {:available-shares (- available-shares shares)}))))

  ;; (defn sell-shares [token-id shares]
  ;;   (let [me (MSG_SENDER)
  ;;         id (get-hash token-id me)]
  ;;     (with-default-read realestate-table token-id
  ;;       {sell-price       :sell-price
  ;;        available-shares :available-shares
  ;;        owner              :owner}
  ;;       (with-default-read stakeholder-table id
  ;;         {:shares -1}
  ;;         {holder :holder hold-shares :shares}
  ;;         (enforce (not= (-1 hold-shares)))
  ;;         (enforce (>= hold-shares shares) "Not Enough Shares")
  ;;         (send me owner (* curr-price shares))
  ;;         (update realestate-table token-id {:available-shares (+ available-shares shares)})
  ;;         (update stakeholder-table id {:shares (- hold-shares shares)})))))

  (defn shares-of [token-id]
    (let [me (MSG_SENDER)]
      (with-read stakeholder-table (get-hash token-id me)
        {shares :shares}
        shares)))

  (defn dividend-one [per-share owner id]
    (with-read
      stakeholder-table id
      {id :id holder :holder shares :shares}
      (if (= id (get-hash token-id me))
        (let [div (* per-share shares)]
          (TRANSFER owner holder div)
          div))))
  
  (defn token.dividend [token-id per-share]
    (with-read realestate-table token-id
      {total-shares :total-shares owner :owner}
      (let [per-share (/ amount total-shares)]
        ;; 校验总金额是为了解决除法不精确的问题？
        ;; 若出现除不尽则用户无法解决
        ;; 可以通过设置 maxAmount 来处理
        (enforce (= (fold (+) 0
                          (map (dividend-one per-share owner)
                               (keys stakeholder-table)))
                    amount)))))
)
